<!DOCTYPE html>
<html>
<head>
    <title>Mouse Data Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash/4.17.21/lodash.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #000;
            background: white;
        }
        .light-cycle {
            margin-left: 20px;
            font-size: 14px;
        }
        .tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            display: none;
            z-index: 100;
        }
        .estrus-marker {
            fill: #ff69b4;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Mouse Data Analysis</h1>
    <div class="controls">
        <select id="genderSelect">
            <option value="female">Female</option>
            <option value="male">Male</option>
        </select>
        <select id="mouseSelect"></select>
        <select id="metricSelect">
            <option value="temp">Temperature</option>
            <option value="act">Activity</option>
        </select>
        <div class="light-cycle">
            Light cycle: 12h on/12h off<br>
            Starts at hour 0
        </div>
    </div>
    <div id="visualization"></div>
    <div class="tooltip"></div>

<script>
const width = 1200;
const height = 600;
const margin = { top: 40, right: 150, bottom: 50, left: 60 };

// Create SVG
const svg = d3.select("#visualization")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

// Initialize scales
const xScale = d3.scaleLinear()
    .domain([0, 24])  // Changed to include full range
    .range([margin.left, width - margin.right]);

const yScale = d3.scaleLinear()
    .domain([1, 15])  // Changed to include full range
    .range([margin.top, height - margin.bottom]);

// Color scales with gentler gradients
const activityColorScale = d3.scaleSequential()
    .domain([0, 100])
    .interpolator(d3.interpolateOranges);

const tempColorScale = d3.scaleSequential()
    .domain([35.5, 38.5])
    .interpolator(t => d3.interpolateRdYlBu(1 - t));  // Reversed for better visual

// Create axes
const xAxis = d3.axisBottom(xScale)
    .ticks(24)
    .tickFormat(d => d + ":00");

const yAxis = d3.axisLeft(yScale)
    .ticks(14)
    .tickFormat(d => "Day " + d);

svg.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(xAxis);

svg.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(yAxis);

// Add labels
svg.append("text")
    .attr("class", "x-label")
    .attr("text-anchor", "middle")
    .attr("x", (width - margin.right + margin.left) / 2)
    .attr("y", height - 10)
    .text("Hour of Day");

svg.append("text")
    .attr("class", "y-label")
    .attr("text-anchor", "middle")
    .attr("transform", "rotate(-90)")
    .attr("x", -(height - margin.bottom + margin.top) / 2)
    .attr("y", 20)
    .text("Day");

// Add legend
function addColorLegend(scale, metric) {
    // Remove existing legend
    svg.selectAll(".legend").remove();

    const legendWidth = 20;
    const legendHeight = height - margin.top - margin.bottom;
    const legendX = width - margin.right + 40;

    // Create gradient
    const defs = svg.append("defs");
    const gradient = defs.append("linearGradient")
        .attr("id", "legend-gradient")
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", 0)
        .attr("x2", 0)
        .attr("y1", legendHeight)
        .attr("y2", 0);

    // Add color stops with more intervals for smoother gradient
    const numStops = 20;  // Increased for smoother gradient
    for (let i = 0; i <= numStops; i++) {
        const t = i / numStops;
        const value = scale.domain()[0] + t * (scale.domain()[1] - scale.domain()[0]);
        gradient.append("stop")
            .attr("offset", `${t * 100}%`)
            .attr("stop-color", scale(value));
    }

    const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${legendX}, ${margin.top})`);

    // Add gradient rectangle
    legend.append("rect")
        .attr("width", legendWidth)
        .attr("height", legendHeight)
        .style("fill", "url(#legend-gradient)");

    // Add scale axis
    const legendScale = d3.scaleLinear()
        .domain(scale.domain())
        .range([legendHeight, 0]);

    const legendAxis = d3.axisRight(legendScale)
        .ticks(8)  // Increased number of ticks
        .tickFormat(d => metric === 'temp' ? d.toFixed(2) + '°C' : d.toFixed(0));

    legend.append("g")
        .attr("transform", `translate(${legendWidth}, 0)`)
        .call(legendAxis);
}

// Function to update visualization
async function updateVisualization() {
    const gender = d3.select("#genderSelect").property("value");
    const mouseId = d3.select("#mouseSelect").property("value");
    const metric = d3.select("#metricSelect").property("value");
    
    try {
        const fileName = `${gender}_${metric}.csv`;
        const response = await d3.csv(fileName);
        
        // Process minute-level data into hourly averages
        const minutesPerDay = 1440;
        const minutesPerHour = 60;
        const data = [];

        // Get all mouse IDs for averaging
        const allMouseIds = Object.keys(response[0]).filter(key => 
            key.startsWith(gender === 'female' ? 'f' : 'm'));

        // Process each day
        for (let day = 0; day < 14; day++) {
            const dayStart = day * minutesPerDay;
            const dayData = [];

            // Process each hour
            for (let hour = 0; hour < 24; hour++) {
                const hourStart = dayStart + (hour * minutesPerHour);
                const hourEnd = hourStart + minutesPerHour;
                
                let hourValues;
                if (mouseId === 'Average') {
                    // Calculate average across all mice for this time period
                    hourValues = response
                        .slice(hourStart, hourEnd)
                        .map(row => {
                            const mouseValues = allMouseIds.map(id => parseFloat(row[id]))
                                .filter(val => !isNaN(val));
                            return d3.mean(mouseValues);
                        })
                        .filter(val => !isNaN(val));
                } else {
                    // Single mouse data
                    hourValues = response
                        .slice(hourStart, hourEnd)
                        .map(row => parseFloat(row[mouseId]))
                        .filter(val => !isNaN(val));
                }

                // Calculate average for the hour
                const hourAvg = hourValues.length > 0 
                    ? d3.mean(hourValues)
                    : null;

                dayData.push({
                    day: day + 1,
                    hour: hour,
                    value: hourAvg,
                    isLightOn: hour >= 12 // Light cycle starts at 0 (off)
                });
            }
            data.push(...dayData);
        }

        // Clear previous elements
        svg.selectAll(".data-point").remove();
        svg.selectAll(".estrus-marker").remove();

        // Calculate rectangle dimensions
        const cellWidth = (width - margin.left - margin.right) / 24;
        const cellHeight = (height - margin.top - margin.bottom) / 14;

        // Create cells for the heatmap
        svg.selectAll(".data-point")
            .data(data)
            .enter()
            .append("rect")
            .attr("class", "data-point")
            .attr("x", d => xScale(d.hour))
            .attr("y", d => yScale(d.day))
            .attr("width", cellWidth)
            .attr("height", cellHeight)
            .attr("fill", d => {
                if (d.value === null) return "#ccc";
                return metric === 'temp' 
                    ? tempColorScale(d.value) 
                    : activityColorScale(d.value);
            })
            .on("mouseover", function(event, d) {
                const tooltip = d3.select(".tooltip");
                tooltip.style("display", "block")
                    .html(`Day ${d.day}<br>Hour ${d.hour}:00<br>
                          ${metric === 'temp' ? 'Temperature' : 'Activity'}: 
                          ${d.value ? d.value.toFixed(2) : 'N/A'}
                          ${metric === 'temp' ? '°C' : ''}<br>
                          Light: ${d.isLightOn ? 'On' : 'Off'}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", function() {
                d3.select(".tooltip").style("display", "none");
            });

        // Add estrus markers for female mice
        if (gender === 'female') {
            [2, 6, 10, 14].forEach(day => {
                svg.append("text")
                    .attr("class", "estrus-marker")
                    .attr("x", width - margin.right + 10)
                    .attr("y", yScale(day))
                    .text("★ Estrus");
            });
        }

        // Add color legend
        addColorLegend(metric === 'temp' ? tempColorScale : activityColorScale, metric);

    } catch (error) {
        console.error("Error loading data:", error);
    }
}

// Initialize mouse select options
function updateMouseOptions() {
    const gender = d3.select("#genderSelect").property("value");
    const mouseIds = gender === 'female' 
        ? ['Average', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13']
        : ['Average', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9', 'm10', 'm11', 'm12', 'm13'];
    
    const mouseSelect = d3.select("#mouseSelect");
    mouseSelect.selectAll("option").remove();
    
    mouseIds.forEach(id => {
        mouseSelect.append("option")
            .attr("value", id)
            .text(id);
    });
}

// Event listeners
d3.select("#genderSelect").on("change", () => {
    updateMouseOptions();
    updateVisualization();
});

d3.select("#mouseSelect").on("change", updateVisualization);
d3.select("#metricSelect").on("change", updateVisualization);

// Initialize
updateMouseOptions();
updateVisualization();
</script>
</body>
</html>